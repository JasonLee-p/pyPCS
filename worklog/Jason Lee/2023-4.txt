pyPCS
4.5
第一次写日志，浅浅写一下目前这个库目前都有什么：
1.class PitchSeries， Rhythm， PitchClassSeries, PitchSegment and their element tree.
类 音符序列，节奏（时值序列），音级集序列， 音集截段（截段），还有他们自己的元素树。
2._player module witch can play single notes, PitchSeries, Rhythm, Chord, PitchSegment, chord progression.
可以播放单音，音符序列，节奏（时值序列），和弦，音集截段（截段）和 和弦进行 的模块

今日内容：
修复：
1.PitchSeries和Rhythm类中输出的新对象名的后缀中，去除了不必要的"with/without rhythm"描述；
新增：
1.PitchClassSeries类(依照PitchSeries）
计划新增：
一.ContourSegment类（轮廓截段）
二.在Chord类里开发一个全新的和弦体系，包含对调性音乐中对和弦色彩，张力和功能性的解释和在无调性音乐中的类似体系(暂时未找到，可以试着在后调性理论导论里找找思路)
1.第一步，将哔哩哔哩“自动化和声生成算法”视频中的五度圈和弦体系在程序中实现。(需要先研究一下基本概念）
2.针对这个体系做出自己的改良，比如考虑非柱式和弦，泛音（也需要考虑音色），音强和 前面出现的延音 对和声效果的影响。
3.第三步，利用整个体系提供的各项参数对实例乐谱进行分析，得出一些结论以便自动生成和弦进行。
三.写一个随机生成对位声部的算法，通过单声部截段随机生成符合基本对位法的对位声部，并且得到这段对位的一些数据，比如音符密度倾向性等。这可以用类Counterpoint来封装。

4.7
新增：
    一.函数chord_dissonance，用于判断和弦的不和谐度，处于试验阶段。
背景：
    依据《色彩和声》第352页“谱例7-4 和弦紧张度等级划分细则”确定和弦的紧张度等级，再根据“紧张度-协和度关系图”确定协和度量化值的方法有局限性，因此笔者希望能把目前对音程协和度的研究成果拓展到和弦上，力争开发一个有别于华氏紧张度算法的更有力的工具，以解决音强，排列两个因素对和弦紧张度的影响。
音程—不协和度表（大致）：
0 : 0  ,
1 : 5.5, 2 : 3.3, 3 : 2  , 4 : 2.3, 5 : 1.5, 6 : 2.8, 7 : 0.5, 8 : 2.8, 9 : 1  , 10: 1.8, 11: 2.9, 12: 0,
13: 2.2, 14: 1.5, 15: 1  , 16: 1.2, 17: 0.7, 18: 1.4, 19: 0  , 20: 1.4, 21: 0.5, 22: 0.9, 23: 1.4, 24: 0,
25: 1  , 26: 0  , 27: 0.4, 28: 0  , 29: 0.3, 30: 0.6, 31: 0  , 32: 0.6, 33: 0.2, 34: 0.1, 35: 0.6, 36: 0,
方案1：
    根据该表，得到和弦内的每两个音之间的音程不协和度，求平均值。
方案2：
    根据该表，得到“最低音之外的某一个音”和”每一个低于该音的音“之间的音程的平均值，然后得到”最低音之外的所有音“的该值，求平均值。
实验结果：
    C_0 = pyPCS.Chord([48, 60, 64, 67])
    C_1 = pyPCS.Chord([48, 55, 60, 64])
    C_2 = pyPCS.Chord([48, 52, 55, 60])
    C_3 = pyPCS.Chord([60, 64, 67])
    C_4 = pyPCS.Chord([48, 55, 64, 67])
    C_5 = pyPCS.Chord([48, 55, 64])
    CM7_0 = pyPCS.Chord([48, 55, 59, 64])
    CM7_1 = pyPCS.Chord([60, 64, 67, 71])
    C7_0 = pyPCS.Chord([48, 55, 58, 64])
    C7_1 = pyPCS.Chord([60, 64, 67, 70])
    方案一：
    C: 1.0
    C: 1.0833333333333333
    C: 1.5166666666666666
    C: 1.5999999999999999
    C: 0.7833333333333333
    C: 0.9
    CM7: 1.5666666666666664
    CM7: 1.75
    C7: 1.55
    C7: 1.8999999999999997
    方案二：
    C: 0.8611111111111112
    C: 0.9166666666666666
    C: 1.6611111111111112
    C: 1.775
    C: 0.7555555555555555
    C: 0.8
    CM7: 1.4444444444444444
    CM7: 1.8166666666666664
    C7: 1.3555555555555554
    C7: 1.9166666666666667
结论：
1.两个方案均有 排布对不协和度影响过大 的问题：比如第三第四个低音排布更密集的C和弦（都包含根音八度内的三音），不协和度计算结果远高于其他C和弦的排布方式。造成这个结果的原因可能是，大音程的不协和度数据过低，可能会导致非常稀疏的排列方式反而让和弦不协和度非常低。
2.但是在相似的排布下，该模型可以对C，CM7， C7的不协和度做出一定的区分。
新方案：
暂未想到
